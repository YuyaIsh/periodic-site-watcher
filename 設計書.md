# 定期巡回Chrome拡張 設計書（個人運用・シンプル優先 / hourly起床 / retry=1h固定）

## 1. 目的
- 指定した複数サイトを **定期的に順番に巡回**し、ページ上のデータを取得して **自前APIへ送信**する。
- 失敗時は **次の起床（=1時間後）で再試行**し、復旧後は通常運用へ戻す。
- 変更が発生しやすい要素（頻度/時刻/タイムアウト/対象URL）は **オプション画面で変更可能**にする。
- サイトごとの処理は「抽出ロジックは別」としつつ、**siteIdによる分岐（ディスパッチ）構造**までは実装できる設計にする。

## 2. 非目的
- 並列実行はしない（運用安定性を優先）。
- 複雑なcron式や高度な依存関係（サイト間の前提）は不要。
- DOM抽出の詳細（CSS selector等）は各アダプタ実装で決める（本設計では分岐枠のみ）。

---

## 3. 全体アーキテクチャ
- Chrome Extension (Manifest V3)
  - Service Worker：定期起床、タブ制御、注入/指示、送信、状態更新
  - Content Script（都度注入）：ページ側での抽出処理（siteIdディスパッチ）
  - Options Page：設定編集、storage保存
- Backend（自前API）
  - `POST /collect`：拡張から収集結果を受領し、Notion保存/後続処理へ
  - 日次サマリー（Slack通知）はバックエンド側で実施（拡張は収集に専念）

---

## 4. 実行モデル（重要）

### 4.1 起床（固定：1時間ごと）
- `chrome.alarms` を **1本**だけ作成し、**1時間ごと**に起床する。
- 起床時に storage を読み、各サイトの `state.nextRun` と現在時刻を比較して「実行すべきサイト」だけ処理する。

### 4.2 実行順序
- 実行対象サイトは固定順で **1件ずつ順番に処理**する。
  - 固定順は `siteId` 昇順（再現性と単純さを優先）
- 同時並行はしない。

### 4.3 失敗時（retryは1時間固定）
- 失敗したサイトは `state.nextRun` を **「今から1時間後」**に更新し、次回起床以降に再実行する。
- retryに分単位設定は持たない（誤解と複雑化を避ける）。

---

## 5. データモデル（chrome.storage.local）
- 設定（settings）と状態（state）は分離し、失敗で設定が壊れないようにする。

### 5.1 Settings（ユーザーが変更する設定）
`settings.sites`：サイト別設定（siteIdをキー）

必須フィールド：
- `url: string`：巡回時に開くURL
- `enabled: boolean`
- `timeoutSec: number`：1サイト処理の上限時間（ロード＋抽出＋送信）

スケジュール（サイト別）：
- `schedule: { type: 'hourly' | 'daily' | 'weekly', ... }`
  - hourly：`minute: number`（0-59。毎時この分に実行）
  - daily：`at: 'HH:MM'`
  - weekly：`dow: 0|1|2|3|4|5|6`（0=Sun）, `at: 'HH:MM'`

※ retryは設定に持たない。

### 5.2 State（実行状態）
`state.bySite[siteId]`：
- `nextRun: number`（epoch ms）
- `lastStatus?: 'ok' | 'fail'`
- `failCount?: number`
- `lastRun?: number`
- `lastError?: string`（短い文字列）

---

## 6. 初期化方針
- `settings` が無ければデフォルトを投入。
- `state` が無い／サイトが追加された場合：
  - `state.bySite[siteId].nextRun` を「スケジュールに従う次回時刻」で初期化する。

---

## 7. スケジュール評価（複雑化させない）
### 7.1 実行判定は `nextRun` のみ（not-before）
- 起床ごとに `now >= nextRun` のサイトを実行する。
- `nextRun` は「この時刻以降なら実行してよい（not-before）」として扱う。
  - PCスリープ等で遅れても、次回起床で実行可能になる。

### 7.2 nextRun 計算関数
- `computeNextRunAfterSuccess(now, schedule): number`
  - hourly：次の「毎時 minute」の時刻
  - daily：次の「HH:MM」（今日を過ぎていれば翌日）
  - weekly：次の「dow HH:MM」（今週を過ぎていれば来週）
- `computeNextRunAfterFail(now): number`
  - `now + 1h`

---

## 8. 実行フロー（Service Worker）

### 8.1 起床処理
1. `storage.local.get(['settings','state'])`
2. `now = Date.now()`
3. `sites = Object.keys(settings.sites).sort()`
4. for each `siteId`:
   - if `enabled === false` → skip
   - if `state.bySite[siteId].nextRun > now` → skip
   - else `runSite(siteId)`

### 8.2 1サイト処理（共通骨格：バグ要因削減）
- **タブは毎回新規作成 → 処理後に必ず閉じる**（再利用しない）

手順：
1. `tabs.create({ url, active: false })`
2. `tabs.onUpdated` で対象tabIdの `changeInfo.status === 'complete'` を待つ（`timeoutSec` で打ち切り）
3. content script を都度注入して `collectOnPage(siteId)` を実行し、payloadを受け取る
4. **送信はService Workerが実施**：`POST /collect`
5. 成功/失敗に応じて state 更新
6. `tabs.remove(tabId)`

---

## 9. サイト分岐（siteIdディスパッチ：分岐だけ実装）
### 9.1 分岐の責務
- `siteId` に応じて **適切なアダプタ関数を呼ぶ**。
- アダプタ関数は「抽出ロジックの器」として存在し、詳細は別途実装する。
- 未対応の `siteId` は明確に失敗させる。

### 9.2 ディスパッチ方式（最小）
- `collectOnPage(siteId)` が入口
- `switch (siteId)` で分岐
- 各ケースは `collect_<siteId>()` を呼ぶだけ（中身は後で埋める）

### 9.3 返却payload（最小契約）
- `CollectedPayload`（最小）：
  - `siteId: string`
  - `url: string`（`location.href`）
  - `capturedAt: number`（epoch ms）
  - `payload: object`（サイト別自由。分岐枠の段階では `{}` でも可）

---

## 10. state 更新

### 10.1 成功
- `lastStatus = 'ok'`
- `failCount = 0`
- `lastRun = now`
- `nextRun = computeNextRunAfterSuccess(now, schedule)`

### 10.2 失敗（retry=1h固定）
- `lastStatus = 'fail'`
- `failCount = (failCount ?? 0) + 1`
- `lastRun = now`
- `lastError = shortMessage`
- `nextRun = computeNextRunAfterFail(now)`（`now + 1h`）

---

## 11. Backend API（契約）
### `POST /collect`
- Request（最小）：
  - `siteId`
  - `url`
  - `capturedAt`
  - `payload`（任意）
- Response：200 OK（受領）

---

## 12. Options Page（入力欄を並べるだけ）
- サイト一覧（行）
  - siteId
  - enabled
  - url
  - schedule.type（hourly/daily/weekly）
  - scheduleの追加フィールド（minute / at / dow）
  - timeoutSec
- 保存ボタン
- （任意）状態表示（readonly）
  - nextRun / lastRun / lastStatus / failCount / lastError

---

## 13. マニフェスト要件（高レベル）
- permissions：`storage`, `alarms`, `tabs`, `scripting`
- host_permissions：
  - 個人運用でサイト追加前提なら `<all_urls>` を許容（最小の運用摩擦）

---

## 14. 実装タスク分解（Cursor向け）
1. MV3雛形（manifest / SW / options）
2. storage初期化（settings/state）
3. alarms：1時間ごと起床
4. 実行ループ（siteId固定順、nextRun判定）
5. `runSite`（新規タブ作成→完了待ち→注入→送信→state更新→クローズ）
6. `collectOnPage(siteId)`（switch分岐だけ）
   - `collect_moneyforward()`
   - `collect_x_bookmarks()`
   - など（中身は空でOK、最低限payload形だけ返す）
7. options：サイト設定CRUD（最小で保存/表示）

以上
